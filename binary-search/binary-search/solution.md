# [binary-search](https://leetcode.cn/problems/binary-search)

## overview

![image-20241128173101049](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411281731173.png)

题目清晰，不作概述，略。

## solution

首先仍然是暴力解法。按照一定的顺序，比如从左往右，拿各个元素与目标逐个比对。相信很容易理解。

接下来我们在暴力解法的基础上进行优化。我们发现暴力解法的元素淘汰机制有些蹩脚：一次比较只能淘汰一个元素，浪费了数组中的有序特性。那该怎么利用这个特性呢？既然题目提供给我们的数组就是有序的，那就意味着数组中的元素以及要查找的目标都是可以比较的，这种元素的两个个体，都有大于等于小于这三种关系，于是我们就可以利用这个关系优化淘汰机制，让一次比较之后，可以淘汰一群元素。

比如现在输入的数组就是`[1, 2, 3, 4, 5, 6, 7, 8, 9 ]`，而我们要查找的目标是`5`。我们可以在这个数组中任意找一个元素，比如`4`，我们发现`4 < 5`，这意味着在之后的比对过程中`4`及其左边的元素都是不需要考虑的，也就是说之后我们要考虑的数组是`[5, 6, 7, 8, 9]`，接下来我又随便找了一个元素`8`，我们发现`8 > 5`，所以`8`及其右边的元素在之后的比较中都可以不再考虑了，也就是说我们之后要考虑的数组就是`[5, 6, 7]`。

我们把这种特性——对于一个序列来说，可以通过其中的某个元素，将序列分成两部分的性质称之为“二段性”，对于拥有“二段性”的序列来说，我们就可以通过比较序列中一个元素与目标元素的关系，淘汰掉序列两部分中的一部分，从而为接下来的比较减轻工作量。

在上面的举例中，我们是随便选序列元素的，但随便这种东西实在是太随便了，容易重复或遗漏，很明显我们要以一定的规律去寻找划分点——我们把序列中被比较的那些元素称为划分点。具体什么规律呢？我们可以把中间的那个点作为划分点，也可以把三分之一的点作为划分点，甚至是四分之一，五分之一·······，这么多规律，要选什么呢？我们选择数学期望最大的那个，也就是中间的那个点，可以感性的体会一下，但我们使用三分之一作为划分点时，它确实有可能一下子淘汰三分之二，但也有可能只淘汰三分之一，换句话来说，它有一点赌的成分，中间点就不一样了，不管怎样，都会淘汰二分之一，运气好点直接结束，总而言之，中间点的划分规则更优。

可以意识到，该思路的具体代码实现是循环结构。我们先看循环的内容，为了方便起见，我们假设寻找的数组是升序序列，先找中间点，这个中间点不是说一定非要在正中间，有那个意思就行了，不要太过执着于它的具体计算形式，比如这里我可以直接`mid = left + (right - left) / 2`，也可以是`mid = left + (right - left + 1) / 2`，不用太过纠结，毕竟上面我们也说了，三分之一也可以，有中间的意思就行，不过这里最好不要用`mid = (left + right) / 2`，因为当两下标都比较大的时候，容易出现溢出风险，也就是`int`放不下它俩的和；接着就需要对划分点进行比对，如果`nums[mid] < t`，那就`left = mid + 1`，如果`nums[mid] > t`，那就`right = mid -1`，等于就`return`；接下来我们看看循环条件怎么定，注意我这里的`left`和`right`是左闭右也闭的，不是迭代器的那种左闭右开，也就是说`left`和`right`维护的序列是包括`left`和`right`本身所指的元素的，在这种情况下，即使`left == right`，也不能停止循环，毕竟还有一个元素等着比对呢，说不定这最后一个元素就是目标元素，所以循环停止的条件是`left > right`，不过要注意，这里写的是停止条件，`while`里要写的是循环继续条件，所以应该是`left <= right`。

最后讨论一下时间复杂度，第一次循环区间长度变成了$\frac{N}{2^1}$，第二次循环变成了$\frac{N}{2^2}$，第三次是$\frac{N}{2^3}$，多少次能到$N$呢？不就是$log_2N$吗。来个直观的数字体验一下，$2^{32} == 4,294,967,296$，当有这么多的元素时，暴力解法是这么多次。优化后是32次。

## code

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int middle = left + (right - left) / 2;
            if (nums[middle] < target)
                left = middle + 1;
            else if (nums[middle] > target)
                right = middle - 1;
            else
                return middle;
        }
        return -1;
    }
};
```

## template

二分查找是有模版的，这里的模版就是上述代码的抽象。

```cpp
while (left <= right) {
    int middle = left + (right - left) / 2;
    if (······)
        left = middle + 1;
    else if (······)
        right = middle - 1;
    else
        return ······;
}
```

省略号看题目的具体情况。

# end