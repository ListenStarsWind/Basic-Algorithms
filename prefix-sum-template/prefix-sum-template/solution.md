# [prefix-sum-template](https://www.nowcoder.com/share/jump/9209693051733579338388)

![image-20241207215118130](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241207215118349.png)

## overview

这是一道一维前缀和模版题。给定一个长度为n的数组，比如示例中的`[1,2,4]`，接下来进行若干次查询，每次查询指定两个参数，这两个参数描述了一段区间，要求求出该区间内所有元素的和，注意，这两个参数描述的是第几个元素，而非元素下标，并且，选中区间包括这两个参数本身。比如对于`[1,2,4]`来说，第一次查询是`(1,2)`，数组中的第一个元素是`1`，第二个元素是`2`，它们的和是3，第二次查询是`(2,3)`，第二个元素是`2`，第三个元素是`4`，它们的和为6。

## solution

首先还是暴力算法。我们把每次查询当做一次独立的过程，分别对它们进行求解。假设现在用户输入的数组是`[1,4,7,2,5,8,3,6,9]`，

![image-20241208093822327](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241208093822478.png)

比如，有两次次查询。第一次是2到4，那就从2下标开始，一直加到4下标；第二次是3到5，那从3开始，一直加到5下标。如果每次查询都是从头到尾，那么q次查询时间复杂度就是$O(qN)$。

接下来就是前缀和思想。我们再创建一个数组，用来记录每个元素相加后的状态，这样每次查询就是$O(1)$的复杂度。

![image-20241208094703355](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241208094703403.png)

`dp[0]`就是元素的默认构造，对于`int`来说，其实就是0，`dp[1] = dp[0] + arr[1]`，`dp[2] = dp[1] + arr[2]`，`dp[3] = dp[0] + arr[3]`，`dp[i] = dp[i-1] + arr[i]`，也就是说`dp[i]`表示`(1, i)`区间的状态和。

若要查询`(3, 5)`区间的和，只需要先求出`(1, 5)`的区间和再减去`(1, 2)`的区间和，也就是`dp[5] - dp[3-1]`。

这些前缀和的复杂度就应该是$O(q + N)$。

接着我们考虑一下细节：我们把N个元素存在N+1大小数组中，除了方便之外，另外一个重要原因是它可以更便捷地处理边界问题，如果下标从0开始，那么当查询`(0, 4)`的时候，我们就需要做一下特别处理，总不能是`dp[4]-dp[-1]`。下标从1开始就不用考虑这么多，根本不用进行边界处理。

## code

```cpp
#include <iostream>
#include<vector>
using namespace std;

int main() {

    int n, q;
    cin >> n >> q;
    vector<int> arr(n + 1);
    for (int i = 1; i <= n; i++)
        cin >> arr[i];

    vector<long long> dp(n + 1);  // long long 防止状态溢出
    for (int i = 1; i <= n; i++)
        dp[i] = dp[i - 1] + arr[i];

    int l, r;
    while (q--) {
        cin >> l >> r;
        cout << dp[r] - dp[ l - 1] << endl;
    }


    return 0;
}
```

# end