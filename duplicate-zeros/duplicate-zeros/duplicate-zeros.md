# [duplicate-zeros](https://leetcode.cn/problems/duplicate-zeros)

![image-20241110144818011](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101448077.png)

我们先简单地进行一下异地覆写，感受一下大致过程。以[1,0,2,3,0,4,5,0]为例。

![image-20241110145922933](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101459972.png)

![image-20241110150021655](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101500692.png)

![image-20241110150107310](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101501343.png)

![image-20241110150156567](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101501606.png)

![image-20241110150253347](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101502381.png)

![image-20241110150329605](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101503639.png)

![image-20241110150410653](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411101504682.png)

当然我们肯定不会用这种异地操作，上面的图只是用来感受的。接下来我们要做的就是把异地操作移到本地。

下面我们要做的事就是把异地覆写优化为本地双指针覆写。首先需要肯定的是，在进行原地覆写的时候，一定不能从左往右直接进行覆写，否则，大概率会出现未检查的数据被覆写操作破坏的场景。因此，我们需要从后往左进行覆写。如果以上面的图来说，就是先从4那里进行覆写，倒着覆写。

于是，我们接下来的任务就可以细分成两个小问题，一是如何找到最后一个元素，对于上图来说，就是如何找到这个4；第二个小问题，就是倒着进行覆写。

那如何找到最后一个元素呢？我们的思路是模拟正向覆写的过程，所谓模拟就是单纯走个流程，不要真的覆写。我们先将`curr`和`dest`移到初始位置上，然后检查`curr`指向的数字，根据其是否是0来决定`dest`向后迭代的次数：如果元素为非0，则`dest`只向后迭代一次，否则，就迭代两次。

接下来我们要思考一下，`dest`和`curr`初始位置在何处，不能想当然的认为它们都位于0，让我们看看正向覆写时循环结束的场景：`dest`指向了数组后面的一个位置，或者说，越界了，而`curr`也不指向最后一个元素`4`。

很明显，在反向覆写的过程中，是将`curr`指向的元素覆写到`dest`处，这意味着，在正向模拟的过程中，`curr`最终指向最后一个元素，而`dest`最终应该指向数组的最后一个下标。但现在的问题是，一是`curr`不指向最后一个元素`4`，二是，`dest`越界了。如何解决这个问题呢？我们通过两种方式对它们进行调整：一是指针的初始位置，二是指针的迭代规则。

对于`dest`，我们的方法简单而粗暴，直接把它的初始值调为-1即可，它的终止位置就是数组最后一个元素。

对于`curr`来说，因为最后在反向覆写时肯定是以它作为循环是否继续进行的判断条件，所以它的初始位置不能乱动，必须就是0，否则后面会很麻烦的，那既然初始位置这条路走不同，那就只能试试另外一条路了：在迭代方式上进行优化：怎么优化呢？我们把`curr`的迭代放在循环的末尾，当`dest`到达它应该终止的位置时，直接break跳出循环，阻止curr的向后迭代，这相当于给`curr`一份后悔药，本来如果没有break时，它就会迭代到最后一个元素的下一元素，也就是上面图中的那个5，但我现在break了，所以就不会再向后迭代，这样，`curr`最后就能留在最后一个元素的位置上。

不过还有一个问题需要解决，我们知道在上述的正向模拟过程中，`dest`在每轮循环可能会有两种迭代情况，一是向后迭代一次，二是向后迭代两次，会不会发生这种情况，在上一轮迭代过程中，`dest`已经在数组倒数第二个下标了，但在这轮循环中，`dest`将向后迭代两次，这样它就越出了数组，另外，要注意的是，`dest`向后迭代两次意味着`curr`指向的是0，而这轮循环又是最后一轮循环，这意味着，对于该种情况下，最后一个元素一定是0。

如何解决这种情况呢？由于`dest`只能进行向后一次迭代或者向后两次迭代，所以出现这种情况必然意味着此时`dest`就为数组的大小，或者说，它刚好指向数组最后一个元素的下一个位置。此时就需要进行特殊处理，我们直接把最后一个元素写为0，然后让`curr`向前迭代一次，`dest`向后迭代两次即可。

最后的反向覆写反而没什么好说的，循环条件以`curr`为准，`curr`指向的位置为0，就覆写两回，否则就覆写一回。

------------------------

上文是题解的整个逻辑链条，下文，则是ChatGPT根据我本人的上文逻辑做出的详细操作描述。我已对其中的一些错误进行了修正。

### 思路分析与背后逻辑：

对于本题，我们的目标是在给定数组中就地复写每个出现的零，并将其余元素向右平移。在实现中，必须避免从左向右进行直接覆写，因为这种方式会导致数据被破坏。这背后的原因是，当我们从左向右修改数组时，新写入的元素会覆盖掉尚未处理的原始数据，使得后续操作出现错误。

为了解决这个问题，我们选择**从右向左**进行覆写。这样做的核心逻辑是保证在进行修改时，原始数据不会被提前修改覆盖。

### 操作逻辑细分：

1. **找到最后一个元素**：
   - 我们需要模拟正向覆写的过程，以确定从哪开始进行反向覆写。这里的模拟不是真正修改数组，而是通过一个指针 `curr` 来遍历，并使用另一个指针 `dest` 表示模拟中目标写入的位置。
   - 在遍历中，`curr`会根据是否遇到零来推进 `dest`的位置：
     - 如果 `arr[curr]` 非零，`dest` 只移动一次；
     - 如果 `arr[curr]` 为零，`dest` 需要移动两次来表示复写两次零。
   - **为什么从右向左？** 这样可以避免在覆写过程中覆盖尚未处理的数据，保证覆写顺序不影响数据完整性。
2. **指针初始化与边界处理**：
   - `curr` 起始于索引 `0`，而 `dest` 初始位置为**-1**。
   - 模拟过程中，当 `dest` 到达或者超出数组最后一个元素时，我们break跳出循环，停止遍历。这确保了 `curr` 最终会停留在需要进行反向覆写的最后一个元素上。
3. **特殊情况分析**：
   - 在模拟过程中，如果 `dest` 进入数组末尾后又要移动两次，意味着当前的 `curr` 指向的是一个零。此时的处理逻辑是将数组最后一个元素直接设为零，并调整 `curr` 和 `dest` 以继续反向操作。
   - **为什么要特殊处理？** 这是因为在反向覆写时，需要确保数组的边界元素能够正确处理，不出现遗漏或错误复写的情况。

### 最终反向覆写的逻辑：

从找到的最后一个元素位置开始，`curr` 向左遍历并逐步写入 `dest`：

- 如果 `arr[curr]` 是零，`dest` 连续写两次零；
- 如果 `arr[curr]` 不是零，`dest` 写一次当前值。

这种从后向前的遍历方式背后的逻辑是为了确保在修改数组时，右侧的原始数据不会受到修改的影响，保持了数据完整性并满足就地修改的要求。

代码：

```cpp
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int current = 0;
        int destination = -1;
        int sz = arr.size();
        while (current < sz) {
            if (arr[current])
                destination++;
            else
                destination += 2;
            if (destination >= sz - 1)
                break;
            current++;
        }

        if (destination == sz) {
            arr[sz - 1] = 0;
            current--;
            destination -= 2;
        }

        while (current >= 0) {
            if (arr[current])
                arr[destination--] = arr[current];
            else {
                arr[destination--] = arr[current];
                arr[destination--] = arr[current];
            }
            current--;
        }
    }
};
```

# end