# [min-rotated-array](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array)   

![image-20241204205103307](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241204205103391.png)

## overview

题目给我们一个数组，该数组是由一个升序数组经过若干次旋转而得到的。比如现有一个升序数组`[0,1,2,4,5,6,7]`，每次旋转都相当于把最后一个元素提到开头，比如，该数组旋转一次后是`[7,0,1,2,4,5,6]`，旋转两次就是`[6,7,0,1,2,4,5]`，旋转三次就是`[5,6,7,0,1,2,4]`，旋转四次就是`[4,5,6,7,0,1,2]`，现在的需求是找到该数组中最小的元素。

## solution

首先，我们可以考虑暴力算法，直接遍历整个数组即可找到最小元素，具体过程在此不再详细叙述。

为了进一步优化，我们引入一个概念：“回归数”。回归数指的是将旋转后的有序数组恢复到其初始状态所需的旋转次数。例如，给定升序数组 `[0, 1, 2, 4, 5, 6, 7]`，它的回归数就是 7。实际上，对于一个严格升序的数组来说，它的最小回归数等于数组的元素个数。我们将这一过程称为“回归”。

接下来，我们探讨如何优化算法。在数组尚未回归时，可以通过以下图示来描述其元素之间的相对大小关系。

![image-20241204211551755](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241204211551855.png)

在这个问题中，假设我们将数组看作一个旋转后的有序数组，其中 A 点表示数组的首元素，D 点表示数组的最后一个元素，而 B 点和 C 点分别是数组的极值。我们的目标是找到 C 点，也就是数组中的最小值。

通过观察，可以发现对于尚未回归的子数组，元素的相对大小关系仍然成立。例如，对于数组 `[4, 5, 6, 7, 0, 1, 2]`，其子数组 `[6, 7, 0, 1]` 依然呈现出类似的趋势。这意味着，我们可以将问题转化为在子数组中寻找最小值，从而逐步缩小问题的范围，提高效率。

此时，我们应该意识到这里适合使用二分查找。接下来，我们需要从上述趋势中提炼出关键规律，使得我们能够将数组划分为两个子数组，从而减少需要考虑的元素数量。

什么关键规律呢？可以看看A点或者D点，比如说对于A点来说，所有处于AB段的元素都存在`A <= nums[i]`，而对于CD点来说，都存在`A > nums[i]`。又比如，对于D点来说，所有处于AB段的元素都存在`D > nums[i]`，所有处于CD段的元素都存在`D <= nums[i]`，基于这一规律，我们可以不断将数组划分为两个子数组，从而减少处理的范围。

我们先看D点。先定义两个指针维护探讨数组的范围，最开始，它们就是数组的第一个元素和最后一个元素，也就是`left=0, right = size() - 1`，接下来我们找一个中间点，如果该中间点位于AB段`nums[mid] > nums[right]`，那么`left = mid + 1`，否则`nums[mid] <= nums[right]`就`right = mid`，可以很容易看出，`left`是开拓者，所以我们向下取整，`mid = left + (right - left) / 2;`

接下来我们考虑一下极端情况，也就是回归状态，如果回归状态下该思路仍然可行，那就真的可行了，所谓回归状态，就是说现在我们研究的子数组已经是有序的了，在`left`和`right`迭代机制的保护下，可以肯定，最后数组若是回归了，其一定在CD段。接下来我们看看之后继续照着这个思路能不能找到C，由于该段的所有元素都小于等于D，所以会一遍遍地触发`right`迭代机制，所以最后`left`和`right`可以在最小点相会。

接下来看看A点，A点在非回归状态下与D点行为相似，就不分析了，但关键是，若是现在的数组已经回归了，鉴于CD段都小于A点，就会触发`left`的迭代机制，而`right`一次都不动，这样最后到达的就是回归时的最后一个元素，所以是不行的。

## code

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() -1;
        while(left < right)
        {
            int mid = left + (right -  left) / 2;
            if(nums[mid] > nums[right])
                left = mid + 1;
            else
            right = mid;
        }
        return nums[left];
    }
};
```

# end
