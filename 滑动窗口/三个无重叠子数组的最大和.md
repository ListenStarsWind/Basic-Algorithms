# [三个无重叠子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/)

![image-20250608172313393](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250608172313976.png)

## 算法原理

本题是一道多滑动窗口的题目, 对于多滑动窗口的题目来说, 我们需要注意的是, 每一级的窗口都需要维护自已所依赖的前面的所有窗口, 而不仅仅是前一个窗口的状态和位置信息, 在最后进行答案更新时, 都使用最后一个窗口的前一个窗口所维护的状态量, 而不要使用各自窗口的独立状态量, 至于具体的细节, 请看代码注释

## 代码编写

```cpp
/*
    解法一: 滑动窗口
    既然题目让我们找三个子数组, 那么我们可以同时维护三个滑动窗口我们分别从0, k, 2k, 这三个位置开始, 对滑动窗口进行积累, 
    让它们的窗口大小同时都变为k, 此时由于我们的起始下标是从0, k,2k-1开始的, 所以当这三个窗口第一次同时满的时候, 它们正好
    处于不重叠的极限状态, 在之后的操作中, 三个窗口将同步出元素, 这样在每一个时间片上, 这三个窗口都是紧挨的, 都处于恰好不会
    重叠的程度, 当然, 我们大概率不是取同一个时间片上的三个窗口, 而是取不同时间片上的窗口, 由于是处于不同时间片上的窗口, 所
    以必然存在时间的先后之分, 这就相当于有些窗口它停留在了过去, 没有继续出窗口, 可别的窗口还在继续出窗口, 这就会造成它们之
    间不是紧挨的, 既然都不是紧挨的, 那么自然更不会重叠, 至于多情况下的字典序由于我们出窗口都是从左往右, 一步步把最前面的那
    个元素剔除的, 所以即使存在多种情况, 我们的这种方案天然就是下标字典序最小的

    在代码的具体编写中, 我们将会维护三个变量用来记录那些历史上和最大的组合, maxSize1表示历史最大的窗口一元素和, 在窗口一进行
    更新时会尝试对其进行更新, maxSize12表示历史最大的组合: 窗口一和窗口二, 它们两个的元素和最大, 在实际计算中, 我们会拿历史上
    最大的窗口一作为此处窗口一的大小, 此处的言外之意是maxSize1 要先尝试进行更新, 然后再尝试更新maxSize12, maxSize12的尝试更新
    实际就是窗口二出元素的时候, 当然, 考虑到三个窗口是同时出窗口的, 也可以说, maxSize1, maxSize12是同时尝试更新的, 只不过有
    一些顺序要求, 因为maxSize12依赖maxSize1, 所以maxSize1要在前面进行更新, 最后的第三个变量 maxSize123也是如此, 它表示历史上
    元素和最大的组合, 窗口一, 窗口二, 窗口三, 窗口一和窗口二的最大 依赖于 maxSize12, 需要先进行更新

    在进行下标更新时, 需要稍微注意一下, 由于窗口一更新, 并不意味着窗口二也会进行更新, 可能窗口二变得很小, 把窗口一的增加掩盖掉了
    所以, 但窗口一又需要保留历史最大的那个起始下标, 而对于第三个窗口来说, 可能出现第二个窗口未被更新, 也就是说第二个窗口依赖的第
    一个窗口的起始下标没有更新, 所以此时对下标数组进行更新时, 仍旧应该选择之前的窗口一下标, 和窗口二下标, 这就意为这, 窗口二还要
    自己维护一个变量, 记录自己所依赖的那个窗口一其实下标, 至于窗口一, 由于它前面没有窗口, 所以不需要, 每次maxSize12更新的时候, 就
    把依赖的窗口一下标改成当前最大的窗口一大小

    具体的下标映射公式可以找个实例随便套一套, 比如012345678, k是三
    窗口一起点0, 窗口二起点3, 窗口三起点6, 当遍历到8时, 第一次窗口全满
    最大历史窗口的其实坐标是刚加上的元素坐标减去(k-1)
*/

class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int sum1 = 0, sum2 = 0, sum3 = 0;
        int maxSum1Idx1 = 0, maxSum2Idx2 = 0, maxSum12Idx1 = 0;
        int maxSize1 = 0, maxSize12 = 0, maxSize123 = 0;
        
        vector<int> ans;
        int n = nums.size();
        for(int i = 2*k; i < n; ++i)
        {
            sum1 += nums[i - 2*k];
            sum2 += nums[i - k];
            sum3 += nums[i];

            if(i >= 3*k-1)
            {
                if(sum1 > maxSize1)
                {
                    maxSize1 = sum1;
                    maxSum1Idx1 = i - 3*k + 1;
                }
                if(maxSize1 + sum2 > maxSize12)
                {
                    maxSize12 = maxSize1 + sum2;
                    maxSum12Idx1 = maxSum1Idx1;
                    maxSum2Idx2 = i - 2*k + 1;
                }
                if(maxSize12 + sum3 > maxSize123)
                {
                    maxSize123 = maxSize12 + sum3;
                    ans = {maxSum12Idx1, maxSum2Idx2, i - k + 1};
                }
                sum1 -= nums[i - 3*k + 1];
                sum2 -= nums[i - 2*k + 1];
                sum3 -= nums[i - k + 1];
            }
        }

        return ans;
    }
};
```

# 完

