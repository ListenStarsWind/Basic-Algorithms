# [three-sum](https://leetcode.cn/problems/3sum)

![image-20241114192238504](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411141922574.png)

---------------

让我们先读读题？根据题目，我们知道，算法的任务是从数组`nums`中找到`nums[i]  nums[j]  nums[k]`三个数，并且三个下标互不相等，需求是让这三个数的和为0。
我们特别要看看它的注意：答案中不可以包含重复的三元组。那么，问题就来了，什么样才算是重复的呢？题目没有明确说，这就需要结合示例来看了。

在示例一中，我们获得的数组是`[-1,0,1,2,-1,-4]`，在查找之后，我们得到了三个搭配：`[-1, 0, 1]   [0, 1, -1]   [-1, 2, -1]`，但它最后只录用了两个，这就让我们知道了，重复指的是内容的重复，比如`[-1, 0, 1] and [0, 1, -1]`就是重复的；除此之外，还需要注意的是顺序问题，这里的顺序有两层意思，一是单个三元组中的数字顺序是无所谓的，既可以是`[-1, 0, 1]`，也可以是`[0, 1, -1]`；二是返回时三元组的顺序是无所谓的，我们既可以先返回`[0, 1, -1]`，再返回`[-1, -1, 2]`，也可以先返回`[-1, -1, 2]`，再返回`[0, 1, -1]`，当然，我这里说的是返回容器的下标顺序，不是说返回两组三元数。

示例二的意思是存在找不到的情况，此时返回空容器就行了。

--------------

我们第一个思路当然是暴力破解。使用穷举法搭配出每种可能，然后去看看和是不是0。然后就有一个大问题了，要去重，怎么去重呢？可以先排序再穷举，你看那个注意它也说了顺序无所谓，说不定就是暗示我们排序呢。比如我们拿示例1进行排序，这样就可以得到数组`[-4, -1, -1, 0, 1, 2]`，此时再穷举就会得到`[-1, 0, 1]   [-1, 0 ,1]  [-1, -1, 2]`，此时重复的三元组就完全相同了。

不过有可能有多组三元数都是相同的，这时候就要用`set`了，把和为0的三元组全扔`set`里，然后再拿出来，就能去重了。

------------------

接下来是第二个思路，都排完序了还能用穷举吗？看看能不能用双指针。比如现在数组是`[-4, -4, -1, 0, 0, 1, 1, 4, 4, 5, 6]`。我们的策略是先锚定一个数，然后从它另一边的区间再找出两个数。比如，对于上面的数组来说，我们可以先锚定最左边的-4，然后从它的右边再找出两个数，使得这两个数的和为4就行，两数之和的题目我们刚才才说过，很简单的。

首先锚定-4，接着我们发现-4 + 6 < 4，所以再看-1 + 6 > 4，所以就要看 -1 + 5 == 4，那就找到一组了，然后把这三个数扔进返回容器里就行了。

接下来我们要想想去重，这次不用`set`，很明显，面试的时候面试官肯定想让你尽可能靠自己，而不是说用个`set`去重。这时候，排序就又体现出一个优点了。比如现在锚定的还是最左边的-4，然后左指针指向的是最左边的0，右指针指向的是最右边的4，也是符合要求的一组，之后本来`left`应该加加，结果我们发现，`left`指向的还是0，这时候`right`还是最右边的4，还是符合要求，不过它重复了，那我们就可以优化一下它们的迭代机制，让`left`跳过那些相同的区间，直接把第二个0跳过去，来到1，而对于`right`来说，你也跳过倒数第二个4，也直接来到1。除此之外，还要注意的是，锚点数的迭代机制也是跳过相同数的，比如最左边-4现在已经找完了，本来应该把第二个-4作为锚点，但那样就重复了，所以跳过，直接锚定-1。

不过，这就又带来了一个问题，如果可以跳着迭代的话，那万一跳越界了怎么办？所以每次迭代还要保证不要越界。

至此，我们的思路其实就可以通过了，但实际上，我们还可以做一个小优化。当锚定的数是正数时，可以直接跳出循环，因为当锚定数为正数时，意味着它将要从右边找到两个数的和是负数，但这个数组已经排过序了，所以不可能有这种情况，因此，可以直接跳出循环。

---------------

下面是代码：

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ret;

        sort(nums.begin(), nums.end());

        int sz = nums.size();
        int anchor = 0;
        while (anchor < sz - 2) {
            if (nums[anchor] > 0)
                break;

            int left = anchor + 1;
            int right = sz - 1;
            int key = -nums[anchor];

            while (left < right) {
                if (nums[left] + nums[right] < key) {
                    left++;
                    while (left < right && nums[left - 1] == nums[left])
                        left++;
                } else if (nums[left] + nums[right] > key) {
                    right--;
                    while (left < right && nums[right + 1] == nums[right])
                        right--;
                } else {

                    ret.push_back({nums[anchor], nums[left], nums[right]});

                    left++;
                    while (left < right && nums[left - 1] == nums[left])
                        left++;
                    right--;
                    while (left < right && nums[right + 1] == nums[right])
                        right--;
                }
            }

            anchor++;
            while (anchor < nums.size() - 2 && nums[anchor - 1] == nums[anchor])
                anchor++;
        }
        return ret;
    }
};
```



# end