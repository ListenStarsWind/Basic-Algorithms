# [subarray-sums-divisible-by-k](https://leetcode.cn/problems/subarray-sums-divisible-by-k)

![image-20241218093426428](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241218093426736.png)

## overview

题目已经很明确了，在此略过。

## solution

首先，仍旧是暴力枚举。还是使用两个指针枚举出所有可能的子数组，每得出一个子数组，看看它是否符合要求，符合，计数器就加一。

接下来，我们要运用前缀和思想对该题进行解答。

在正式讲解思路前，我们需要先了解一个数学定理，同余定理，这个定理有两个作用，一是将问题转化为一个更简单的问题，二是让我们知道在C/C++中，如何对负数取余的结果进行修正。

同余定理的内容如下：
对于两个整数`a`和`b`来说，如果有`(a+b)%m == 0`，则有`a % m == b % m`。

举个例子，`(26 -12) % 7 == 0`，则`26 % 7 == 12 % 7`。

怎么证明呢？首先我们要知道，`(a + p * k) % p = a % p`，因为取余实际上就是让被除数不停地减去除数，直到被除数比除数小为止，比如`7 % 2`，`7`先减去`2`变成`5`，`5`再减去`2`变成`3`，`3`再减去`2`变成`1`，`1`不够减`2`了，所以余数就是`1`，当然，即使没有减完，比如减到`3`就停下来了，它还是适用的。

现在来证明同余定理，`(a - b) ÷ m = k`，则`a - b = m * k`，有`a = b + m * k`，两边同时模`m`，`a % m = (b + m * k) % m`，化简得`a % m = b % m`。

接下来说第二点：对C++负数取模的结果进行修正。

我们知道，对于C++来说，负数 % 正数 = 负数，余数哪有负数呢？所以我们要把得到的结果进行修正，把它变成正数。

C++负数取模得到的结果其实是模的负数表示，比如`5 % 3 = 2`，它的模就是`3`，对于`2`来说，它既可以认为是`2`，也可以认为是`-1`，因为模是`3`，满`3`就进一，所以`-1 mod(3)`就是`2`。

现在我们举负数例子` -5 % 3 = -1`，所以如果我们像把结果变成正数，只需要再加上模就行了，也就是`a % m + m`，不过这对于正数来说，又不适用了，所以我们还需要修正一下`(a % m + m) % m`，举个例子，`-5 % 3`我们想要的结果是`2`，用前面的公式是适用的，另外，`5 % 3`用上面的公式也是可以的。

现在我们正式进行思路讲解，我个人认为，前缀和的思想精髓是：将总过程拆分为不可分割的子过程，这些子过程之间按照一定的顺序排列，具有直接或间接的递推关系，并通过记录每次迭代后的状态，为后续问题的快速求解提供支持。

就像上一道题，也就是上一篇文章：
![image-20241216213746666](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241216213746774.png)

我们对于备选数组的查找仍旧是使用上一道题的方式，先选取一个从下标0开始的子数组，然后再把这个子数组进行划分，划分成两个部分，第一个部分是从下标0开始的一个更小的子数组，第二个部分就是我们的备选数组，如果把选中区域的元素和称之为`m`，把第一部分的元素和称之为`n`，则第二部分的元素和为`m -n`。

![image-20241218105252761](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241218105252845.png)
![image-20241218105420633](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241218105420673.png)
![image-20241218105546532](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241218105546576.png)
![image-20241218105736922](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241218105736963.png)

根据同余定理，如果`(m - n) % k == 0`，则`m % k == n % k`，所以问题就变简单了，我们现在的任务就是，先求出`m % k`的值，然后再看看`hash`里有几个相同的余数即可，也就是说，`hash`里放的是数组元素和取余的结果，不过因为`m`和`n`有为负数的可能，所以记得要修正一下。

接下来我们想一下`hash`最开始的状态是什么，最开始`hash`还没有记录任何子数组的信息，所以可以认为此时`hash`遍历了一个空数组，空数组的元素和是`0`，`0`模任何数仍为`0`。

## code

```cpp
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        hash[0]++;
        int sum = 0, remainder = 0, count = 0;
        for (auto e : nums) {
            sum += e;
            remainder = (sum % k + k) % k;
            if (hash.count(remainder))
                count += hash[remainder];
            hash[remainder]++;
        }

        return count;
    }
};
```

