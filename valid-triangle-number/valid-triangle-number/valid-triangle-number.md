# [valid-triangle-number](https://leetcode.cn/problems/valid-triangle-number)

![image-20241112171948886](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411121719948.png)

我们拿示例一来举例：[2, 2, 3, 4]

它一共有三种排列组合：[2, 2, 3]  [2, 2, 4]  [2, 3, 4]  [2, 3, 4]这四种排列组合，其中[2, 2, 3]  [2, 3, 4]  [2, 3, 4]是可以组成三角形的，所以返回3。注意[2, 3, 4]  [2, 3, 4]里的2可不是同一个2，所以也是要计入的。

我们首先要优化一下判断三个数是否能组成三角形的方法。比如，现在有三个数 a b c，我们想判断一下它们是否能组成三角形，那就使用三角形任意两边之和大于第三边的方式，这样，我们必须要判断一下：a + b > c	a + c > b	b + c > a	。只有这三个表达式都成立才能确认a b c确实可以组成一个三角形。但这样做太麻烦了，要比较三次，虽然三次看上去并不多，但很有可能的是，后面我们为了在数组中选出谁充当这三个数，可能需要几层循环，而三角形的判断方法必然在最内层的循环，这意味着，这个3是要乘上前面循环的复杂度的，如果，前面循环的复杂度本身就很高，那么复杂度就会有很大的增长，所以，在正式处理数组之前，我们先要进行一道预处理，将数组变为有序的，之后，选中这三个数后，就可以通过它们下标的左右顺序直接判断这三个数的相对大小，然后，假如 a b c的下标是从左往右依次排列的，这样就能知道c是最大的，然后仅依靠 a + b > c这一个表达式就足以证明这三个数可以组成三角形。

数组在排完序后，就有了很强的规律性，比如排完序的数组是单调的。我们以[2, 2, 3, 4, 5, 9, 10]来举例。我们先锁定三数中的最大数，现在在这个数组中最大的数就是最后一个下标的元素，也就是10，然后我们再去找两个较小数。

我们先把被锁定较大数左边的两个极值，也就是锁定数前一个，和数组第一个数，在这个场景下，就是2和9作为另外两个数，我们发现2 + 9 > 10是成立的，也就是说2,  9, 10可以组成一个三角形，既然2 + 9 > 10是成立的，那么对于2右边的那些数来说，2[下标为1的那个2] + 9 > 10		3 + 9 > 10		4 + 9 > 10		5 + 9 > 10		必然都是成立的，我们不需要再对它们进行判断，连上最开始的那个 2 + 9  > 10，就已经一次性找出五种搭配了，所以此时计数器就可以直接加五。

在上面的过程中，我把10称为强锁定状态，9称为弱锁定状态，剩下的第三个数就从弱锁定左边的数里找，在做完上面的过程中，我们已经找到了10为强锁定，9为弱锁定的可以组成三角形的所有情况。接下来，就要更换弱锁定了，我们把以前弱锁定的前一个元素作为新的弱锁定，也就是把5作为弱锁定。

我们发现2 + 5 > 10是不成立的，这说明，第三个数，额，就叫自由位吧，选取的数字太小了，那就调大自由位，改成2？不行，改成3？不行，改成4？不行。那就都不计数。

在上面的过程中，我们的自由位和弱锁相遇了，这意味我们不用再更换弱锁了，因为即使在弱锁为5的时候，直到自由位与弱锁相遇，我们也找不到一个可以组成三角形的搭配，那在弱锁为4,  3,  2的时候就更不可能了，此时整个强锁为10的搭配我们都检查过了，这会，该更换强锁了，把它换成9，然后重复上面的过程。

直到强锁左边的数字已经不足以达到三个时完全结束循环。

```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int anchor = 0;
        int count = 0;
        for (anchor = nums.size() - 1; anchor >= 2; anchor--) {
            int pivot = anchor - 1;
            int scout = 0;
            while (scout < pivot) {
                if (nums[scout] + nums[pivot] > nums[anchor]) {
                    count += pivot - scout;
                    pivot--;
                } else {
                    scout++;
                }
            }
        }
        return count;
    }
};
```

在ChatGPT的帮助下，我为强锁定，弱锁定，自由位找到了符合意象的翻译，`anchor`是锚点的意思，锚定了我们接下来的操作；`pivot`是支点的意思，突出它的调整需要遵循一套机制，`scout`是探子的意思，自由地为我们探索可能的组合。

# end