# [subarray-sum-equals-k](https://leetcode.cn/problems/subarray-sum-equals-k)

![image-20241216213746666](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20241216213746774.png)

## overview

题目非常简洁，就是让我们从输入数组中找一些子数组，这些子数组的元素和等于输入的另一个参数`k`即可，最后返回满足要求的子数组个数。

## solution

首先仍旧是暴力解法：仍是两个指针`left`和`right`，它们都从0下标开始，每一次大循环，`left`向后迭代一个单位，每次大循环内部有若干次小循环，每次小循环`right`向后迭代一个单位，每轮小循环结束后，检查一下`left`和`right`维护的子数组，看看是否等于`k`，等于则计数器加一，`right`到结尾后回到`left`，这样时间复杂度就是$O(N^2)$，可惜`nums`里面有负数，否则就可以优化成滑动窗口了。

接下来我们看看能不能用前缀和，在前面的学习过程中，我们意识到前缀和的本质还是穷举，只不过由于之前的预处理，导致穷举的效率大大提升，所以接下来我们要想的就是该如何用前缀和的方式穷举子数组的所有可能性。

前缀和是从0号下标开始的，但子数组不一定从0开始，所以我们要采用间接的方式寻找子数组，比如我们假设`nums = [3, 4, 7, 2, -3, 1, 4, 2, -2]
k = 7`，我们选中一个从下标0开始的研究区域，比如`[3, 4, 7]`，所形成的对应前缀和数组应该是`[0, 3, 7, 14]`，如果要算`[3, 4, 7]`这个子数组的元素和，那就是`14-0`，要算`[4, 7]`这个子数组元素的和就是`14-3`，要算`[7]`这个子数组元素和就是`14-7`，这样我们就找到了所有以下标2为结尾符合要求的子数组，接着我们把研究区域变成`[3, 4, 7, 2]`，去寻找以下标3为结尾符合要求的子数组。

这就是核心思路，下面我们在这个核心思路的基础上，进行代码级别的优化。为什么要优化呢？因为如果真的建一个数组去逐个遍历的话，效率反而比直接穷举效率低，所以我们要在代码形式上作优化，还是拿`nums = [3, 4, 7, 2, -3, 1, 4, 2, -2], k = 7`为例，现在我们的研究区域就是`[3, 4, 7]`，对应的前缀和数组是`[0, 3, 7, 14]`，研究区域的所有元素和为`14`，`k = 7`，所以我们实际要干的是，看看前缀和数组里有几个`14-7`，正如你所见，有一个，所以计数器加一，所以我们要干的是建立一个`key-value`模型的哈希表，就比如现在这种情况，哈希表就是`{{0, 1}, {3, 1}, {7, 1}}`，`first`表示前缀和数组的元素，`second`表示对应的出现次数，我们要找的是`14-7`，`7`有一个所以就加一。

刚开始哈希表是`{{0 , 1}}`，因为可能存在从下标0开始的子数组，另外要注意的是，前缀和不是一股脑全扔进哈希表的，在计算以`i`为结尾的子数组个数时，哈希表中要存储`[0, i-1]`数组的前缀和信息，比如对于`[3, 4, 7]`来说，现在是查找以`2`下标为结尾的子数组，所以当前哈希表是`{{0, 1}, {3, 1}, {7, 1}}`，然后我们先算出`i`的前缀和`sum(这次迭代) = sum(上次迭代) + nums[i]`，然后再查看`sum - k`的个数，最后再把`sum`扔进哈希表，接着进行下一次迭代。

## code

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        hash[0]++;

        int sum = 0, count = 0;
        for(auto e : nums)
        {
            sum += e;
            if(hash.count(sum-k)) count += hash[sum-k];
            hash[sum]++;
        }
        return count;
    }
};
```

