# [happy-number](https://leetcode.cn/problems/happy-number)

![image-20241112125141288](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411121251414.png)

我们先根据题目给出的两个示例来画一画图：

![image-20241112132030131](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411121320181.png)

![image-20241112132533682](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411121325721.png)

从这两张图可以看到，最终都形成了环状结构。实际上，题目中已经明确表示只有这两种情况。这两种情况最终都会出现环，而如果环中包含数字 1，那么它就会以 1 为循环模式持续下去。稍后我们会证明为什么这些情况最终都会形成环，但现在我们先着手解决这道题。

这两幅图看起来是否有点像链表？除了初始节点外，每个节点都是由前一个节点经过迭代生成的。在学习 C 阶段时，我们曾经接触过链表成环的相关问题，并使用快慢指针法来判断链表是否成环。由于两个指针的移动速度不同，如果链表成环，最终它们会因为速度差而指向环中的同一个节点。

在这道题中，我们已经知道链表必定成环。因此，我们只需模拟判断链表成环的过程，找到环中的一个节点，并检查该节点是否为 1 即可。

```cpp
class Solution {
public:
    int iterator(int n) {
        int ret = 0;
        while (n) {
            int tmp = n % 10;
            ret += tmp * tmp;
            n /= 10;
        }
        return ret;
    }

    bool isHappy(int n) {
        int fast = n;
        int slow = n;
        do {
            fast = iterator(fast);
            fast = iterator(fast);
            slow = iterator(slow);
        } while (fast != slow);
        return fast == 1;
    }
};
```

接下来，我们来证明为什么这种情况一定会形成环。

首先需要了解“鸽巢原理”或“抽屉原理”：

我们只需掌握其最基础的版本：若有 n 个巢穴，且有 n+1 只鸽子分配到这些巢穴中，那么至少有一个巢穴中会有超过一只鸽子。

题目中对输入数有范围限制：$1 <= n <= 2^{31} - 1$，即正数 `int` 的范围。我们知道 `INT_MAX` 是 `2147483647`，这是一个10位的十进制数。将此数的每个位进行平方求和，我们得到的结果是 260。

因此，我们可以得出一个结论：不论输入的 `int` 是多少，它经过一次迭代后的结果都不会超过 260。这意味着，任意输入数字的迭代结果都是 [1, 260] 范围内的某个整数。而 [1, 260] 只有 260 个不同的整数，所以如果对输入数字进行 261 次迭代，就一定会出现重复结果，从而形成一个环。

# end