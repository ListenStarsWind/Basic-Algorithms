# [revers-pairs](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof)

![image-20250114122258215](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250114122258301.png)

## overview

首先, 我们需要知道什么是逆序对.  所谓逆序对, 就是一对数, 前一个数大于后一个数, 仅此而已.

比如, 现有一个数组`[7, 5, 6, 4]`, 请你找到其中所有的逆序对.  我们先固定一个数, 然后在剩下的数里找, `[7, 5]`, `[7, 6]`, `[7, 4]`, `[5, 4]`, `[6, 4]`,这些都是逆序对, 一共有五个, 所以返回五.

## solution

最开始的解法仍旧是暴力解法, 也就是概述中演示的那样, 使用两层循环, 外层循环固定一个数, 然后内层循环遍历后面的数, 找到比它小的数.

接下来我们使用分治思想.   为了便于理解, 我们从简单到复杂一步一步走.

首先, 我们可以把一个数组分成两个子数组,  我们把"找出整个数组逆序对"这个问题分化为"找出左子数组中的逆序对,  找出右子数组中的逆序对,  从左子树中找出一个数, 再从右子数组中找出一个数, 将两个数组成一对数, 找出这些"一对数"中的逆序对".	

还是`[7, 5, 6, 4]`, 首先它们被分成`[7, 5]`和`[6, 4]`这两个子数组, 接着`[7, 5]`可以再被分为`[7]`, `[5]`这两个子数组, 之后就不可以分了, 所以再回来, 从`[7]`中找出数字`7`, 然后从`[5]`中找出数字`5`, 所组成的数对`(7, 5)`是逆序对, 再回归, 把`[6, 4]`分成`[6]`, `[4]`这两个子数组, 回归, 从`[6]`, `[4]`中各找一个数, 组成数对`(6, 4)`是逆序对, 随后再从`[7, 5]`中找出`7`, `[6, 4]`中找出`[6]`, 组成了有序对`(7, 6)`, 从`[6, 4]`中找出`4`, 组成逆序对`(7, 4)`, 再从`[7, 5]`中找出`5`, 从`[6, 4]`中找出`6`, 不能组成逆序对, 从`[6, 4]`中找出`4`, 组成逆序对`(5, 4)`.

从上面的过程中, 我们可以看到, "在一左一右找逆序对"的环节可以进行优化, 我为什么每从左子树中找出一个数后, 就从右子树开头重新遍历呢? 我们不妨在该环节之前先对左子树和右子树进行排序, 我们是一左一右搭配的, 即使两个子数组都排过序, 原先在左子树的元素依旧在左子树, 右子树中的元素还是在右子树, 左边的元素还是在右边元素的前面.          而且归并排序使用的仍旧是分治, 我们或许可以直接在更深的函数栈帧里, 在那里的一左一右里顺手进行一下归并排序, 毕竟逆序对看的是两个数的大小关系, 归并的时候也是依据此时元素的相对大小再决定谁先进入辅助数组, 它们完全可以放在一个地方去做.

还是拿`[7, 5, 6, 4]`举例.

首先进入第一层函数栈帧, 讨论的数组对象是`[7, 5, 6, 4]`, 可以把它分成两个子数组, `[7, 5]`, `[6, 4]`, 

接着进入第二层函数栈帧, 讨论的数组对象是`[7, 5]`, 可以把它分成两个子数组`[7]`, `[5]`

进入第三层函数栈帧, 讨论的数组对象是`[7]`, 它不可被分割, 无法进行"一左一右"本身也形成不了逆序对

回到第二层函数栈帧

进入第三层函数栈帧, 讨论的数组对象是`[5]`, 它不可被分割, 无法进行"一左一右"本身也形成不了逆序对

回到第二层函数栈帧, 现在探讨的两个子数组是`[7]`, `[5]`, 在第三层中, 我们已经计算了就单对它们自己而言, 逆序对的个数, 现在我们要"一左一右"了, 首先左指针指向`7`, 右指针指向`5`, 它们可以形成逆序对, 较小的数是右指针指向的数, 所以将右指针指向的数拷贝到辅助数组, 辅助数组指针亦移动到下一位,等待新的数字, 我们形成的是升序数组, 现在右指针所指向的数小于左指针所指向的, 这意味这当前左指针后面的那些数也是大于当前右指针指向的数, 所以计数器可以把包括左指针当前指向的数到后面数的个数全部加上, 接着, 右指针向后遍历, 发现越界了, 就不再进行"一左一右", 将另一个数组的剩余元素写入辅助数组.

之后再将辅助数组中的值写回原数组

回到第一层函数栈帧, 现在两个子数组是`[5, 7]`, `[6, 4]`,

进入第二层函数栈帧, 讨论的数组是`[6, 4]`, 可以把它分成两个子数组`[6]`, `[4]`

进入第三层函数栈帧, 讨论的数组对象是`[6]`, 它不可被分割, 无法进行"一左一右"本身也形成不了逆序对

回到第二层函数栈帧

进入第三层函数栈帧, 讨论的数组对象是`[4]`, 它不可被分割, 无法进行"一左一右"本身也形成不了逆序对

回到第二层函数栈帧, 现在探讨的两个子数组是`[6]`, `[4]`, 从`[6]`中取出`6`, 从`[4]`中取出`4`, `6 > 4`, 是逆序对, 把较小的数, 也就是右指针指向的数写到辅助数组中, 这也意味着, `[6]`中`6`后面的那些元素都比`4`大, 所以要把包括`6`的`6`后面的数个数全部加到计数器中, 右指针向后迭代, 越界, 把另一个数组的剩余元素写到辅助数组中, 再写回来.

回到第一层函数栈帧, 现在研究的两个子数组是`[5, 7]`, `[4, 6]` 从`[5, 7]`中取出`5`, 从`[4, 6]`中取出`4`, 因为`5 > 4`, 所以`5`后面的一定也大于`4`, 把个数加到计数器中, 再顺便把`4`写入辅助数组, 然后`[4, 6]`取出`6`,`5 < 6`, 把`5`写入辅助数组, `[5, 7]`选出`7`, `7 > 6`, 是逆序对, 加上对应数字, 把`6`写到辅助数组中, 过程结束, 将另一个数组的剩余元素写入辅助数组中, 再写回去.

退出第一层函数栈帧, 来到起点调用处.  得到结果.

在上面的例子中, 我们用的是升序, 其实也可以用降序的, 若使用降序, 左大于右, 则说明右数组的右边都不用比了, 直接加上个数.

## code

```cpp
class Solution {
public:
    void merge(vector<int>& nums, int left, int right, vector<int>& temp, int& count) {
        if (left >= right) 
            return;

        int mid = left + (right - left) / 2;
        merge(nums, left, mid, temp, count);
        merge(nums, mid + 1, right, temp, count);

        int i = left, j = mid + 1;
        int k = left;
        while (i <= mid && j <= right) 
        {
            if (nums[i] > nums[j]) 
            {
                temp[k++] = nums[j++];
                count += mid - i + 1; 
            } 
            else 
            {
                temp[k++] = nums[i++];
            }
        }

        while (i <= mid) 
        {
            temp[k++] = nums[i++];
        }
        while (j <= right) 
        {
            temp[k++] = nums[j++];
        }

        for (int i = left; i <= right; ++i) 
        {
            nums[i] = temp[i];
        }
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> temp(n);
        int count = 0;
        merge(nums, 0, n - 1, temp, count);
        return count;
    }
};


class Solution {
public:
    void merge(vector<int>& nums, int left, int right, vector<int>& temp, int& count) {
        if (left >= right) 
            return;

        int mid = left + (right - left) / 2;
        merge(nums, left, mid, temp, count);
        merge(nums, mid + 1, right, temp, count);

        int i = left, j = mid + 1;
        int k = left;
        while (i <= mid && j <= right) 
        {
            if (nums[i] <= nums[j]) 
            {
                temp[k++] = nums[j++];
            } 
            else 
            {
                temp[k++] = nums[i++];
                count += right - j + 1;
            }
        }

        while (i <= mid) 
        {
            temp[k++] = nums[i++];
        }
        while (j <= right) 
        {
            temp[k++] = nums[j++];
        }

        for (int i = left; i <= right; ++i) 
        {
            nums[i] = temp[i];
        }
    }

    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        vector<int> temp(n);
        int count = 0;
        merge(nums, 0, n - 1, temp, count);
        return count;
    }
};
```

 ## end

