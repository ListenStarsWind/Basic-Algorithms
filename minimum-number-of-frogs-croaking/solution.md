# [minimum-number-of-frogs-croaking](https://leetcode.cn/problems/minimum-number-of-frogs-croaking)

![image-20250107122630757](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250107122630844.png)

## overview

给你一个字符串`croakOfFrogs`, 该字符串中包含多个以分立或者集聚方式呈现的`croak`, 每个`corak`都表示一个完整的蛙叫, 现要你依据`croakOfFrogs`返回所有蛙鸣所需不同青蛙的最少数目.

对于示例一来说, 其`croakOfFrogs = "croakcroak"`, 最开始, 当然是新来一个青蛙, 发出蛙叫, 所以青蛙个数加一, 这个青蛙完成一个完整的蛙叫后, 就闲置下来了, 后来有出现一个`c`, 意味着新的蛙叫开始, 由于题目所需的是最少的青蛙数目, 所以可以让之前那个闲置的青蛙叫过来, 让它发出叫声, 所以最后返回一.

对于示例二来说, 首先来一个青蛙开始叫, 还没叫完, 就又来了一个`c`, 说明又来一个青蛙叫.  最后它们都叫完了, 所以返回2.

对于示例三来说, 首先新来一个青蛙, 发出完整的叫声, 于是它就闲置下来了, 接着又遇到一个`c`, 意味着新的蛙叫开始了, 于是就可以把原来闲置的青蛙拉过来, 让它发出叫声. 首先有效的`c`字符个数加一, 接着是`r`, `r`前面应该发出`c`, 而现在确实有有效的字符`c`, 所以青蛙可以继续叫下去, 接着遇到了`r`, `r`前面应该发出`c`, 但现在没有剩下的`c`了, 所以这次蛙叫失败了, 蛙叫失败就返回-1, 表示字符串非法. 

## solution

从上面的概述中其实已经有了一点模拟影子了.  我们需要对`croakOfFrogs `, 进行逐个遍历, 每遍历一个字符, 就看一下其在`croak`前一个字符有没有叫过, 我们当然不能走一半再折回去, 所以需要一个哈希容器去记录之前遍历到的字符. 而对于`croak`的首字符`c`来说, 还需要特别处理, `c`意味着蛙叫的开始, 而最后一个字符`k`叫完就意味着蛙叫的结束, 蛙叫可能是新来一个青蛙叫出的, 也可能是原来已经做完整个蛙叫流程的青蛙叫出的, 所以如果`k`对应的个数为正, 就说明有闲着的青蛙, 就要把它们拉过来发出叫声, 拉过来之后这青蛙就不闲着了, 所以要把`k`对应的个数减去一.

我们举个例子, 假如`croakOfFrogs  = "crcoakroakcroak"`,  我们先建一个哈希表

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |

首先是`c`, `c`要进行特殊处理, 此时`k`的个数为0 , 意味着没有闲置的青蛙, 那就只能找一个新青蛙了, 

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 0    | 0    |

接着是`r`, `r`前面要有`c`, `c`确实有个数

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 0    | 0    | 0    |

又来一个`c`, 那就只能来个新青蛙了.

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 0    | 0    | 0    |

`o`前面需要有`r`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 0    | 0    |

`a`前面需要有`o`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 1    | 0    |

`k`前面需要有`a`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 0    | 1    |

`r`前面要有`c`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 0    | 0    | 1    |

`o`前面要有`r`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 1    | 0    | 1    |

`a`前面要有`o`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 1    | 1    |

`k`前面要有`a`

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 2    |

`c`意味着有了一个新的叫声, `k`现在为正数, 所以可以把一个闲置的青蛙拉来

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 0    | 1    |

之后再来一遍过程

| c    | r    | o    | a    | k    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 2    |

最后我们发现, 除了最后一个字符外, 其它字符都为0, 这意味着, 字符串中所有的蛙叫都是完整的, 没有叫到一半就结束, 所以直接返回`k`的个数.

在实际代码中, 我们可以使用一个数组来作为哈希表, 我们可以将`croak`中的字符以下标的形式作映射, 此时`c`就是下标0, `k`就是下标4,  如果要找前一个字符的话, 先找到当前字符的在数组中的位置, 然后减一, 就能找到前一个字符了. 当然, 第一个字符`c`需要特别处理.

## code

```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs, string cry = "croak") {
        // 字符串 "croak" 的长度，用于索引数组
        const int len = cry.size(); 

        if (croakOfFrogs.size() % len) 
        {
            // 如果总长度不能被 "croak" 的长度整除，则不可能形成完整的 "croak" 序列
            return -1; 
        }

        // 计数数组，用于记录每个字符（'c', 'r', 'o', 'a', 'k'）出现的次数
        vector<int> count(len); 

        for (char c : croakOfFrogs) 
        {
            // 找到字符 c 在 "croak" 中的位置
            int idx = cry.find(c); 
            if (idx == string::npos) 
            {
                // 如果字符 c 不在 "croak" 中，则字符串非法
                return -1; 
            }

            if (idx == 0) 
            { 
                // 如果是字符 'c'
                if (count[len - 1]) 
                {
                    // 让闲置的青蛙发出叫声
                    count[len - 1]--; 
                }
                 // 一个青蛙开始叫  (可能是从闲置那里来的, 也可能是新来的)
                 count[0]++; 

            } 
            else 
            {
                if (count[idx - 1]) 
                {
                    // 前一个字符青蛙叫过了
                    // 这个字符被使用了
                    count[idx - 1]--; 

                    // 当前字符青蛙叫了一次
                    count[idx]++; 
                   
                }
                else
                {
                    // 前一个字符青蛙没叫
                    return -1;                
                }
                
            }
        }

        // 是否存在没叫完的
        for (int i = 0; i < len - 1; ++i) 
        {
            if (count[i]) 
            {
                return -1;
            }
        }

        return count[len - 1]; // 返回最少得青蛙数目
    }
};
```

# end