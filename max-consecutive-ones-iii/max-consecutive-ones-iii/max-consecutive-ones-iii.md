# [max-consecutive-ones-iii](https://leetcode.cn/problems/max-consecutive-ones-iii)

![image-20241122113527998](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202411221135067.png)

## overview

由题目可知，我们将获得一个只包含`1`或`0`这两个元素的二进制数组和一个整数`k`，然后尝试对该数组中的`0`进行一定次数的取反——使之变为`1`，取反次数的要求是小于等于`k`，之后把数组中最长的连续1子数组找出来，返回它的长度。

以示例一为例，我可以<span style="color: red;">翻转</span>这两个0:  [1, 1, 1, <span style="color: red;">0, 0,  </span>0, 1, 1, 1, 1, 0]使之变为[1, 1, 1. 1, 1, 0, 1, 1, ,1, 1, 0]的形式，于是`len`就是5；也可以<span style="color: red;">翻转</span>这两个0： [1,  1,  1,  0,  <span style="color: red;">0,  0,  </span>1,  1,  1,  1,  0]使之变为[1, 1, 1. 0, 1, 1, 1, 1, ,1, 1, 0]，这样`len`就是6；也可以<span style="color: red;">翻转</span>这两个0： [1,  1,  1,  0,  0   <span style="color: red;">0,     </span>1,  1,  1,  1,  <span style="color: red;">0,     </span>]使之变为[1, 1, 1. 0, 0, 1, 1, 1,  1, 1, 1]，这样`len`就是6，最后我们返回最长的`len`，即6。

如果把示例一的`k`变为5，那只需要把全部0翻转即可。

## solution

首先我们要把题目中的“翻转”这种表现形式进行优化，很明显，由于我们要进行多轮长度比较，所以不能破坏原始数据，也就是不能真的直接翻转数组元素，我们的策略是把这种形式转化成寻找子数组，这个子数组中`0`的个数不大于`k`即算作有效，最后返回最长的那个子数组大小即可。

最开始的方法仍然是暴力破解。在数组中找到所有符合要求的子数组，仍然以示例一为例，首先把`left`固定为0，随着`right`的向后迭代就能得到子数组[1],   [1,  1],   [1,  1,  1],  [1,  1,  1,  0],   [1,  1,  1,  0,  0]，然后`right`就不能再往后迭代了，因为再往后`0`的个数就超标了，为了判断子数组中`0`的个数是否超过`k`，可以定义一个计数器记录当前维护子数组中`0`的个数。

接下来如果继续暴力破解的思路，应该是把`left`向后迭代一次，然后再把`right`移回`left`所在位置，接着`right`继续往后迭代，但可以想到，在以这种方式重新固定起始点之后`right`仍然停留在上一次迭代的位置，因为`right`是依据子数组中`0`的个数来决定是否继续迭代的，下标`1`又不是0，它影响不了`right`的停止位置。

所以我们的优化逻辑就是不要再让`left`一个一个往后迭代，而是也依据`0`的个数决定是否要继续迭代，当`left`遇到`0`之后，子数组中的`0`就少了一个，于是就可以让`right`接着之前停下的位置继续向后迭代。

所以就可以用移动窗口思路了。

初始状态下，`left`和`right`都为0.

接着`right`向后迭代，扩大子数组范围，直到子数组不满足要求

子数组不满足要求后，就要记录一下上一次迭代前刚好处于边界要求的合法数组长度，将该长度与原长度进行比较，如果现在长度更长，则更新`len`

接着让`left`往后迭代，直到子数组再次合法为止，此时就继续让`right`向后迭代。

## code

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0, right = 0, len = 0, zeroes = 0, sz = nums.size();

        while (right < sz) {
            if (nums[right++] == 0)
                zeroes++;
            while (zeroes > k)
                if (nums[left++] == 0)
                    zeroes--;
            len = max(len, right - left);
        }

        return len;
    }
};
```


# end