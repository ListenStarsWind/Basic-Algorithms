# [flood-fill](https://leetcode.cn/problems/flood-fill)

![image-20250317174607707](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250317174607941.png)

## overview

从本题开始, 我们将进入一个全新的专题, 那就是宽度优先遍历`BFS`, 对于BFS, 有很多具体的应用, 比如本题的`flood-fill`算法, `flood-fill`问题直译为洪水灌溉, 现有一块`m * n`大小的矩阵土地, 其中的每个小格具有不同的高度, 我们这里用负数来表示凹进去的地块, 用正数表示凸起来的地块. 

![image-20250317180240386](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250317180240450.png)

然后, 发生了洪水, 或者下雨, 总之那些凹进去的地块就被水淹了, 我们要做的就是找到其中有多少个水域, 或者问哪个水域面积最大, 水域这种词描述并不明显, 我们可以看下面的图, 如图, 这里共有三个水域.

![image-20250317180616053](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250317180616109.png)

我们这里是上下左右相连的, 像图中的`-3`和`-2`是斜对角, 所以无法连通, 但在某些题目中, 斜对角也是要被视为连通的. 此时就有八个方向了.

对于`flood-fill`有两种解决思路, 一是深度优先搜索`DFS`.     深度优先搜索先从起点开始, 不断往深处走, 直到走不了了, 再回头找别的路径. 比如, 对于上图来说, 首先从右上角的`-1`开始, 看看`-1`的上下左右, 发现下面的`-2`是可以走的, 来到`-2`之后, 发现还可以继续往下走, 于是来到`-10`, 到了`-10`之后, 发现还是可以往下走, 于是来到了`-12`, `-12`发现不能往下走了, 于是看看`-12`的上下左右, 也没有地方可走, 于是就回到之前的`-10`, 在`-10`看看上下左右, 发现`-4`可以去, `-4`之后, 发现不能继续往左走了, 于是上下左右看看, 来到了`-3`, `-3`不能往上走了, 看看上下左右, 不行, 回到`-4`, 再看看上下左右, 不行. 回到`-10`再看看上下左右, 不行, 回到`-2`, 再看看上下左右, 不行, 回到`-1`, 再看看上下左右, 不行, 退出

另外的思路就是我们要说的宽度优先搜索`BFS`. 它是一层一层地找, 还是从`-1`开始, 先看看上下左右, 发现`-2`可以去, 来到`-2`之后, 再上下左右, 发现`-3`可以去, `-10`可以去, 接着对`-3`, 看看上下左右, 发现`-4`可以去, 接着是`-10`, 发现`-12`可以去, 接着是`-4`, 没有可去的地方了, 接着是`-12`, 也没有可去的地方了. 结束.

## solution

对于本题来说, 我们可以引入一个队列, 从起点位置开始, 看看上下左右, 把符合要求的放入队列中, 当队列为空时, 就意味着已经遍历完毕.

就实际代码中, 我们可以引入两个偏移量数组, 这样就可以很方便的求出上下左右的坐标.  然后用个两次循环实现思路, 外层循环是从队列中取数据, 内层循环是根据取出的坐标找出上下左右的外延方块. 把满足要求的再放入队列即可.  需要注意的是, 要防止坐标越界, 所以要提前看一下`m, n`到底有多大.

## code

```cpp
class Solution {
    typedef pair<int, int> PXY;
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int key = image[sr][sc];
        if(key == color) return image;  // 如果找不到可供修改的方块, 就直接停止

        int m = image.size(), n = image[0].size();
        queue<PXY> q;
        q.emplace(sr, sc);
        while(!q.empty())
        {
            auto [a, b] = q.front();
            image[a][b] = color;
            q.pop();
            for(int i = 0; i < 4; ++i)
            {
                int x = a + dx[i], y = b + dy[i];
                if(x>=0 && x < m && y>=0 && y < n && image[x][y] == key)
                    q.emplace(x, y);
            }
        }
        return image;
    }
};
```

# end