# [course-schedule](https://leetcode.cn/problems/course-schedule)

![image-20250327213125034](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250327213125101.png)

## overview

今天我们进入`bfs`的最后一个小节, 那就是使用`bfs`解决拓扑排序.

在说拓扑排序前, 我们先要了解几个前置的知识点. 

1. 有向无环图(`DAG图`), 拓扑排序就是在有向无环图上进行的, 有向无环图是高阶数据结构图的一种, 所谓图, 就是有很多点, 点与点之间连接起来. 连接点与点的线就是边, 点就被称为点, 如下图

   ![image-20250327215638653](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250327215638685.png)

   至于有向无环图, 则有两点要求, 一是边都是具有方向的, 而是里无法来到一个已经走过的点, 也就是不成环, 这就是有向无环, 如下图

   ![image-20250327215758751](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250327215758784.png)

   比如, 这里我们再画一条有向边, 就会成环了, 我们走过4还可以再回来

   ![image-20250327215825582](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250327215825624.png)

   有向无环图(第二张图片), 有入度和出度的概念, 入度和出度其实就是描述一个点的出入边情况, 入度就是说, 有多少个边入了这个点, 比如1的入度为零, 2的入度为二, 3的入度为一, 4的入度为二, 5的入度为一, 6的入度为一,                 至于出度, 那就是说有多少边从这个点出去, 1是二, 2是一, 3是二, 4是一, 5是一, 6是零.

2. 顶点活动图(`AOV网`), 顶点活动图, 是有向无环图的一种应用.   在顶点活动图中, 其中的点表示完成某一具体任务的子过程, 边的方向, 表示子过程的先后顺序, 比如下面的顶点活动图表示了       吃青椒炒肉这个任务子过程的先后顺序

   ![image-20250328080620563](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328080620615.png)

   

   比如, 在这里吗,你必须先买菜, 之后才能洗菜, 洗完菜才能切菜, 洗菜和准备厨具都做完了才能腌肉...从中我们也可以看出, `AOV网`是很具有实际意义的. 

3. 拓扑排序,   拓扑排序的概念十分复杂,   我们在此跳过, 我们当前需要知道的, 是拓扑排序的目的: 找到做事情的先后顺序

   比如, 我们可以先买菜, 因为它的入度为零, 也就是没有前置条件.

   ![image-20250328081701420](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328081701469.png)

   买菜做完之后, 洗菜的入度就变为零了, 在这里我们既可以选择"准备厨具", 也可以选择"洗菜", 也就是说, 拓扑排序并不是唯一的, 它可能有多套实现方案.  在这里, 我们就选择"准备厨具".

   ![image-20250328082105375](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328082105427.png)

   接下来只有洗菜是入度为1了, 所以我们只能选择洗菜

   ![image-20250328082223915](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328082223964.png)

   洗完菜之后可以在腌肉和切菜里任选一个, 这里我们就选择腌肉了.

   ![image-20250328083034671](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328083034809.png)

   现在只能选择切菜了, 之后很明显, 我们也只能选择炒菜, 装盘,  干饭了.

   ![image-20250328083222041](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328083222095.png)

4. 如何实现拓扑排序呢? 其实很简单, 那就是把入度为零的点拿出来, 然后把后续相关点的入度减一. 一直重复这个过程就行了.   直到图中没有点或者入度为零的点.

   为什么这里还要加上"或者没有入度为零的点"这一条呢? 因为关于拓扑排序, 还有一个应用就是看有向图是否成环. 比如我们拿出之前的这张图

    ![image-20250327215825582](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250327215825624.png)

   把1, 2, 3个点拿出来之后, 我们会发现, 没有入度为零的点了, 如果一张有向图经过拓扑排序后还有剩余的点没有被拿出来, 那就意味着, 这张图是有环的.

   拓扑排序的具体代码很简单, 那就是先把入度为零的点加入队列中, 然后, 当队列不为空时, 不断循环, 将队头的点拿出来, 然后把它的后续点入度减一, 如果后续点的入度变为零, 那就把它扔进队列.

## solution

关于拓扑排序, 还有一个重要的步骤, 是如何建图.   下面, 我们就本题来说, 如何建图. 

你这个学期需要学习`numCourses`门课程,   为了方面描述, 它们已经被编号为`0 `到 `numCourses-1` .   某些课程有前置课程, 你必须完成前置课程之后, 才能选修它们, 我们用二维数组`prerequisites`描述这些课程的前后关系,   `prerequisites`中的每个元素都是大小为二的二维数组, 构成了一个`pair`, 如`[a, b]`,   `[a, b]`的意思是, 你必须先完成`b`课程才能完成`a`课程. 

请你判断能不能能不能修完全部课程(有没有成环), 能, 返回`true`, 否, 返回`false`.

我们先举一个示例,  比如, 现在`prerequisites`的情况是, `[1,0], [2,0], [3,0], [3,1], [3, 2], [4,3]`, 用图表示就是这样.

![image-20250328091144101](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328091144182.png)

对于建图来说, 有两种思路, 一是使用邻接矩阵(适用于图规模较大的情况), 二是使用邻接表(适用于图规模较小的情况).  我们这里只说邻接表, 

邻接表在逻辑上描述是一个`k`对应若干个`v`的簇
![image-20250328092531085](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250328092531175.png)

为了描述这种逻辑, 我们一方面可以用二维数组, 二维数组中的每个元素都是一个一维数组, 起始的是前面的那个`k`, 后面的元素是后续的`v`,       不过, 更好的方式是使用`unordered_map<int, vector<int>>`, 一方面它的逻辑更接近于上面的示意图, 另一方面, 里可以把`int`换成`string`, 以应对它没有给课程编号的情况. 

邻接表很好的表示了图中点的出度, 但它对于入度的表示还不够便捷, 为此我们还要想个更简单的形式描述一下每个点的入度,  在这里我们可以用`vector<int>`, 这个数组的下标就对应一门具体的课程, 它的值就对应该课程的当前入度, 当然, 如果它没有编号, 再次使用哈希表, 比如`unordered_map<string, int>`也是可以的.   

对于代码来说, 第一步是遍历`prerequisites`, 对表示出度方向的邻接表和表示入度数目的哈希表进行初始化, 接下来是依据哈希表找出那些入度为零的点, 扔进队列里, 然后, 迭代队列, 最后借助于哈希表快速判断是否有未处理的点, 有, 就是成环了, 否则就没成环.

## code

```cpp
class Solution {
    public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        unordered_map<int, vector<int>> edges;
        vector<int> in(numCourses);

        for(const auto& v: prerequisites)
        {
            int a = v[0], b = v[1];
            edges[b].emplace_back(a);
            ++in[a];
        }

        queue<int> q;
        for(int i = 0; i < numCourses; ++i)
        {
            if(in[i] == 0)
                q.emplace(i);
        }

        while(!q.empty())
        {
            auto k = q.front();q.pop();
            for(int e : edges[k])
            {
                if(--in[e] == 0) 
                    q.emplace(e);
            }
        }

        for(int e : in)
            if(e) return false;

        return true;
    }
};
```

# end