# [shortest_path_problem](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze)

![image-20250321175204037](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250321175204296.png)

## overview

这是一个全新的小节.   小节的专题是最短路径问题. 

最短路问题是图论里面的问题, 有很多细的划分, 我们这里说的最短路问题说的是其中最简单的"边权为1的最短路问题".

边权为1的最短路问题较为简单, 即使对图论一概不知也是可以做的.   所谓最短路问题, 就是有很多点, 这些点由各种方式连接, 现在我们要从一个点走到另一个点, 要你求出其中的最短路径. 

我们这里就不画得太复杂了:

![image-20250321180235931](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250321180235984.png)

其中这里面的一个个点在图论中就叫做点, 点与点之间的连线在图论中就叫做边. 边的长度在图论中叫做边权, 当边权都相等时, 每条边的长度就可以视为单位一, 这种就叫做边权为1.

现在要从`A`走到`I`, 要求你求出最短的路径长度.  怎么求呢?   我们的方法就相当于从起点开始使用宽度优先搜索进行一遍穷举, 在穷举过程中逐渐淘汰那些较长的, 最后剩下的就是最短的.

既然是`bfs`, 那自然要有队列, 除此之外, 我们还需要引入一些别的数据结构, 用来描述那些点我们已经去过了, 去过就不要再去了.              我们首先把起点压入队列, 并将A标记为去过了, 然后进入主循环,           把A拿出来, 并把BC压入, BC也被标记为去过,                 接着是把B拿出来, 把D压进去, D也被标记为去过了, 把C拿出来, 把E压进去, E去过了,                     把D拿出来, 发现E已经去过了, 所以这条路径就相当于被淘汰了, 不压入任何数据, 把E拿出来, 把FG压进去, 并标记,                        把F拿出来, 把I压进去, 到达终点, 退出循环, 结束穷举.

单就这种场景来说, 代码逻辑就是两层循环, 外层循环是看队列是否为空, 内层循环是看看当前队列有几个元素, 有多少元素就相当于有几个方案, 它们都需要再进行同步发展或者被淘汰.         至于那个路程的计量, 看外层循环走多少次就行了.

---------

现在回到本题, 题目给我们两个数组, 第一个数组是个二维数组, 描述区域中墙和路的分布, 第二个数组是个pair, 描述起点的坐标.    对于这题来说, 有几个点需要注意, 一是起点不能被当做出口, 即使它就在边界上, 可以看示例三; 二是, 出口就是边界上的那些空格, 三, 来到出口就可以结束了, 不需要越界, 最后的那个越界的路程一是不用被计量的.

如果走不出迷宫, 那就返回-1.

## solution

对于这道题来说, 就可以抽象成边权为1的最短路径问题, 稍有不同的是, 这里有三层循环, 最内层循环是看看上下左右, 看看有那些路径可以走.   标记我们可以用布尔二维数组.

## code

```cpp
class Solution {
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int result = 0;
        bool vis[100][100] = {{false}};
        int m = maze.size(), n = maze[0].size();
        queue<pair<int, int>> q;
        int a = entrance[0], b = entrance[1];
        q.emplace(a, b);
        vis[a][b] = true;
        while (!q.empty()) 
        {
            ++result;
            int size = q.size();
            for (int x = 0; x < size; ++x) 
            {
                auto [i, j] = q.front();
                q.pop();
                for (int k = 0; k < 4; ++k) 
                {
                    int x = i + dx[k];
                    int y = j + dy[k];
                    if (x >= 0 && x < m && y >= 0 && y < n) 
                    {
                        if (maze[x][y] == '.' && vis[x][y] == false) 
                        {
                            if (x == 0 || x == m - 1 || y == 0 || y == n - 1) 
                                return result;
                            else 
                            {
                                q.emplace(x, y);
                                vis[x][y] = true;
                            }
                        }
                    }
                }
            }
        }
        return -1;
    }
};
```

# end